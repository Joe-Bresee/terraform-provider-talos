// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//go:build exclude

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"reflect"
	"strings"

	"github.com/siderolabs/talos/pkg/machinery/resources/block"
)

func resourceMaps() map[string]any {
	return map[string]any{
		"block.DiskSpec": block.DiskSpec{},
	}
}

func main() {
	var g Generator

	g.Printf("// This Source Code Form is subject to the terms of the Mozilla Public\n")
	g.Printf("// License, v. 2.0. If a copy of the MPL was not distributed with this\n")
	g.Printf("// file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n")

	g.Printf("// Code generated by \"diskspec.go\"; DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package talos\n")
	g.Printf("\n")
	g.Printf("import (\n")
	g.Printf("\t\"github.com/hashicorp/terraform-plugin-framework/attr\"\n")
	g.Printf("\t\"github.com/hashicorp/terraform-plugin-framework/datasource/schema\"\n")
	g.Printf("\t\"github.com/hashicorp/terraform-plugin-framework/types\"\n")
	g.Printf("\t\"github.com/siderolabs/gen/xslices\"\n")
	g.Printf("\t\"github.com/siderolabs/talos/pkg/machinery/resources/block\"\n")
	g.Printf(")")
	g.Printf("\n")

	if len(os.Args) < 3 {
		log.Fatalf("usage: %s <type> <resource name>", os.Args[0])
	}

	resourceType := os.Args[1]
	resourceName := strings.ToLower(strings.Split(resourceType, ".")[1])

	resource, ok := resourceMaps()[resourceType]
	if !ok {
		log.Fatalf("unknown type: %s", resourceType)
	}

	blockDiskSpecStruct := reflect.TypeOf(resource)

	g.Printf("type %s struct {\n", resourceName)
	for i := range blockDiskSpecStruct.NumField() {
		tfType, err := mapGoTypesToTFTypes(blockDiskSpecStruct.Field(i).Type)
		if err != nil {
			log.Fatalf("failed to map type %s: %v", blockDiskSpecStruct.Field(i).Type.Name(), err)
		}

		g.Printf("\t%s %s `tfsdk:\"%s\"`\n",
			blockDiskSpecStruct.Field(i).Name,
			tfType,
			strings.ReplaceAll(blockDiskSpecStruct.Field(i).Tag.Get("yaml"), ",omitempty", ""),
		)

	}
	g.Printf("}\n")
	g.Printf("\n")

	g.Printf("var %sAttributes = map[string]schema.Attribute{\n", resourceName)
	for i := 0; i < blockDiskSpecStruct.NumField(); i++ {
		attributeType, err := mapGoTypesToTFAttributeSpec(blockDiskSpecStruct.Field(i).Type)
		if err != nil {
			log.Fatalf("failed to map type %s: %v", blockDiskSpecStruct.Field(i).Type.Name(), err)
		}

		g.Printf("\t\"%s\": %s,\n",
			strings.ReplaceAll(blockDiskSpecStruct.Field(i).Tag.Get("yaml"), ",omitempty", ""),
			attributeType,
		)
	}
	g.Printf("}\n")

	g.Printf("func %sToTFTypes(%sSpec %s) %s {\n", resourceName, resourceName, resourceType, resourceName)
	g.Printf("\treturn %s{\n", resourceName)

	for i := 0; i < blockDiskSpecStruct.NumField(); i++ {
		tfType, err := mapStructTypeToTFType(blockDiskSpecStruct.Field(i), resourceName)
		if err != nil {
			log.Fatalf("failed to map type %s: %v", blockDiskSpecStruct.Field(i).Type.Name(), err)
		}

		g.Printf("\t\t%s: %s,\n",
			blockDiskSpecStruct.Field(i).Name,
			tfType,
		)
	}

	g.Printf("\t}\n")
	g.Printf("}\n")

	src := g.format()

	if err := os.WriteFile(fmt.Sprintf("%s_types.go", os.Args[2]), src, 0o644); err != nil {
		log.Fatalf("failed to write file: %v", err)
	}
}

type Generator struct {
	buf bytes.Buffer
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}

	return src
}

func mapGoTypesToTFTypes(goType reflect.Type) (string, error) {
	// handle the case where the field is a slice
	if goType.Kind() == reflect.Slice {
		switch goType.Elem().Kind() {
		case reflect.String:
			return "types.List", nil
		default:
			return "", fmt.Errorf("unsupported slice type: %s", goType.Elem().Name())
		}
	}

	switch goType.Name() {
	case "string":
		return "types.String", nil
	case "uint", "uint64", "int", "int64":
		return "types.Int64", nil
	case "bool":
		return "types.Bool", nil
	default:
		return "", fmt.Errorf("unsupported type: %s", goType.Name())
	}
}

func mapGoTypesToTFAttributeSpec(goType reflect.Type) (string, error) {
	// handle the case where the field is a slice
	if goType.Kind() == reflect.Slice {
		switch goType.Elem().Kind() {
		case reflect.String:
			return `schema.ListAttribute{
	ElementType: types.StringType,
	Computed:    true,
	}`, nil
		default:
			return "", fmt.Errorf("unsupported slice type: %s", goType.Elem().Name())
		}
	}

	switch goType.Name() {
	case "string":
		return `schema.StringAttribute{
	Computed: true,
	}`, nil
	case "uint", "uint64", "int", "int64":
		return `schema.Int64Attribute{
	Computed: true,
	}`, nil
	case "bool":
		return `schema.BoolAttribute{
	Computed: true,
	}`, nil
	default:
		return "", fmt.Errorf("unsupported type: %s", goType.Name())
	}
}

func mapStructTypeToTFType(structField reflect.StructField, resourceName string) (string, error) {
	// handle the case where the field is a slice
	if structField.Type.Kind() == reflect.Slice {
		switch structField.Type.Elem().Kind() {
		case reflect.String:
			return fmt.Sprintf(`types.ListValueMust(types.StringType, xslices.Map(%sSpec.%s, func(s string) attr.Value {
			return types.StringValue(s)
		}))`, resourceName, structField.Name), nil
		default:
			return "", fmt.Errorf("unsupported slice type: %s", structField.Type.Elem().Name())
		}
	}

	switch structField.Type.Name() {
	case "string":
		return fmt.Sprintf("types.StringValue(%sSpec.%s)", resourceName, structField.Name), nil
	case "uint", "uint64", "int", "int64":
		return fmt.Sprintf("types.Int64Value(int64(%sSpec.%s))", resourceName, structField.Name), nil
	case "bool":
		return fmt.Sprintf("types.BoolValue(%sSpec.%s)", resourceName, structField.Name), nil
	default:
		return "", fmt.Errorf("unsupported type: %s", structField.Type.Name())
	}
}
